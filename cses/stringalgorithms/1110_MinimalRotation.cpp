/*
A rotation of a string can be generated by moving characters one after another from beginning to end.
For example, the rotations of acab are acab, caba, abac, and baca.
Your task is to determine the lexicographically minimal rotation of a string.
Input
The only input line contains a string of length n. Each character is one of a–z.
Output
Print the lexicographically minimal rotation.
Constraints
1≤n≤10^6
Example
Input:
acab
Output:
abac
SOLUTION
Find the rotation that has LOWEST lexicographical order of all such rotations.
Booth's algorithm??
*/
#include <bits/stdc++.h>
#define ll long long
using namespace std;

string solve(string s)
{
    s += s;
    int n = (int)s.size();
    int i = 0;
    int ans = 0;
    while (i < n / 2)
    {
        ans = i;
        int k = i, j = i + 1;
        while (j < n && s[j] >= s[k])
        {
            if (s[j] == s[k])
                k++;
            if (s[j] > s[k])
                k = i;
            j++;
        }
        while (i <= k)
            i += j - k;
    }
    return s.substr(ans, n / 2);
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    string s;
    cin >> s;
    cout << solve(s);
    return 0;
}